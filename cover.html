
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/maxzhovtyj/financeApp-server/cmd/app/main.go (0.0%)</option>
				
				<option value="file1">github.com/maxzhovtyj/financeApp-server/internal/app/app.go (0.0%)</option>
				
				<option value="file2">github.com/maxzhovtyj/financeApp-server/internal/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/maxzhovtyj/financeApp-server/internal/delivery/http/handler.go (0.0%)</option>
				
				<option value="file4">github.com/maxzhovtyj/financeApp-server/internal/delivery/http/v1/handler.go (0.0%)</option>
				
				<option value="file5">github.com/maxzhovtyj/financeApp-server/internal/delivery/http/v1/response.go (83.3%)</option>
				
				<option value="file6">github.com/maxzhovtyj/financeApp-server/internal/delivery/http/v1/users.go (69.0%)</option>
				
				<option value="file7">github.com/maxzhovtyj/financeApp-server/internal/delivery/http/v1/validator.go (100.0%)</option>
				
				<option value="file8">github.com/maxzhovtyj/financeApp-server/internal/repository/repository.go (0.0%)</option>
				
				<option value="file9">github.com/maxzhovtyj/financeApp-server/internal/repository/users_mongo.go (0.0%)</option>
				
				<option value="file10">github.com/maxzhovtyj/financeApp-server/internal/server/server.go (0.0%)</option>
				
				<option value="file11">github.com/maxzhovtyj/financeApp-server/internal/service/mocks/mock.go (100.0%)</option>
				
				<option value="file12">github.com/maxzhovtyj/financeApp-server/internal/service/service.go (0.0%)</option>
				
				<option value="file13">github.com/maxzhovtyj/financeApp-server/internal/service/users.go (0.0%)</option>
				
				<option value="file14">github.com/maxzhovtyj/financeApp-server/pkg/auth/manager.go (42.9%)</option>
				
				<option value="file15">github.com/maxzhovtyj/financeApp-server/pkg/db/mongodb/mongodb.go (0.0%)</option>
				
				<option value="file16">github.com/maxzhovtyj/financeApp-server/pkg/hash/password.go (0.0%)</option>
				
				<option value="file17">github.com/maxzhovtyj/financeApp-server/pkg/logger/logrus.go (9.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/maxzhovtyj/financeApp-server/internal/app"
)

func main() <span class="cov0" title="0">{
        app.Run()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "github.com/maxzhovtyj/financeApp-server/internal/config"
        delivery "github.com/maxzhovtyj/financeApp-server/internal/delivery/http"
        "github.com/maxzhovtyj/financeApp-server/internal/repository"
        "github.com/maxzhovtyj/financeApp-server/internal/server"
        "github.com/maxzhovtyj/financeApp-server/internal/service"
        "github.com/maxzhovtyj/financeApp-server/pkg/auth"
        "github.com/maxzhovtyj/financeApp-server/pkg/db/mongodb"
        "github.com/maxzhovtyj/financeApp-server/pkg/hash"
        "github.com/maxzhovtyj/financeApp-server/pkg/logger"
)

func Run() <span class="cov0" title="0">{
        // Init configs
        cfg, err := config.Init()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span>

        // Init mongo client
        <span class="cov0" title="0">dbClient := mongodb.New(cfg.Mongo)

        // Init token manager client
        tokenManager, err := auth.NewManager(cfg.Auth.JWT.SigningKey)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("failed to import token manager")
        }</span>

        // Init password hashing package
        <span class="cov0" title="0">hashing := hash.NewSHA1Hashing(cfg.Auth.PasswordSalt)

        // Init repository, services and handlers
        repo := repository.New(dbClient.Database(cfg.Mongo.Database))
        s := service.New(repo, tokenManager, cfg.Auth.JWT.AccessTokenTTL, cfg.Auth.JWT.RefreshTokenTTL, hashing)
        h := delivery.New(s)

        // Init and run server
        srv := server.NewServer(cfg, h.Init())
        if err = srv.Run(); err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "github.com/joho/godotenv"
        "github.com/maxzhovtyj/financeApp-server/pkg/logger"
        "github.com/spf13/viper"
        "os"
        "time"
)

const (
        httpHostEnv      = "HTTP_HOST"
        mongoURIEnv      = "MONGO_URI"
        mongoUserEnv     = "MONGO_USER"
        mongoPasswordEnv = "MONGO_PASS"
        passwordSaltEnv  = "PASSWORD_SALT"
        jwtSigningKeyEnv = "JWT_SIGNING_KEY"
)

type (
        Config struct {
                Mongo MongoConfig
                HTTP  HTTPConfig
                Auth  AuthConfig
        }

        AuthConfig struct {
                JWT          JWTConfig
                PasswordSalt string
        }

        JWTConfig struct {
                AccessTokenTTL  time.Duration `mapstructure:"accessTokenTTL"`
                RefreshTokenTTL time.Duration `mapstructure:"refreshTokenTTL"`
                SigningKey      string
        }

        MongoConfig struct {
                URI      string
                User     string
                Password string
                Database string `mapstructure:"databaseName"`
        }

        HTTPConfig struct {
                Host               string        `mapstructure:"host"`
                Port               string        `mapstructure:"port"`
                ReadTimeout        time.Duration `mapstructure:"readTimeout"`
                WriteTimeout       time.Duration `mapstructure:"writeTimeout"`
                MaxHeaderMegabytes int           `mapstructure:"maxHeaderMegabytes"`
        }
)

func Init() (*Config, error) <span class="cov0" title="0">{
        var cfg Config

        logger.Info("loading configuration file...")
        if err := parseConfigFile(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("initialize config from env file...")
        setFromEnv(&amp;cfg)

        logger.Info("unmarshalling config file...")
        if err := unmarshalConfig(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

func setFromEnv(cfg *Config) <span class="cov0" title="0">{
        cfg.HTTP.Host = os.Getenv(httpHostEnv)

        cfg.Auth.PasswordSalt = os.Getenv(passwordSaltEnv)
        cfg.Auth.JWT.SigningKey = os.Getenv(jwtSigningKeyEnv)

        cfg.Mongo.URI = os.Getenv(mongoURIEnv)
        cfg.Mongo.User = os.Getenv(mongoUserEnv)
        cfg.Mongo.Password = os.Getenv(mongoPasswordEnv)
}</span>

func unmarshalConfig(cfg *Config) error <span class="cov0" title="0">{
        if err := viper.UnmarshalKey("mongo", &amp;cfg.Mongo); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := viper.UnmarshalKey("http", &amp;cfg.HTTP); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := viper.UnmarshalKey("auth", &amp;cfg.Auth.JWT); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func parseConfigFile() error <span class="cov0" title="0">{
        viper.AddConfigPath("configs")
        viper.SetConfigName("config")

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error loading .env file")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package delivery

import (
        "github.com/go-playground/validator/v10"
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
        v1 "github.com/maxzhovtyj/financeApp-server/internal/delivery/http/v1"
        "github.com/maxzhovtyj/financeApp-server/internal/service"
)

type Handler struct {
        service   *service.Service
        validator v1.AppValidator
}

func New(service *service.Service) *Handler <span class="cov0" title="0">{
        return &amp;Handler{service: service}
}</span>

func (h *Handler) Init() *echo.Echo <span class="cov0" title="0">{
        router := echo.New()

        router.Use(middleware.Logger())
        router.Use(middleware.Recover())

        v := validator.New()
        router.Validator = &amp;v1.AppValidator{Validator: v}

        h.initAPI(router)

        return router
}</span>

func (h *Handler) initAPI(router *echo.Echo) <span class="cov0" title="0">{
        handlerV1 := v1.NewHandler(h.service)
        api := router.Group("/api")
        </span><span class="cov0" title="0">{
                handlerV1.Init(api)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package v1

import (
        "github.com/labstack/echo/v4"
        "github.com/maxzhovtyj/financeApp-server/internal/service"
        "net/http"
)

type Handler struct {
        service *service.Service
}

func NewHandler(service *service.Service) *Handler <span class="cov0" title="0">{
        return &amp;Handler{service: service}
}</span>

func (h *Handler) Init(api *echo.Group) <span class="cov0" title="0">{
        v1 := api.Group("/v1")
        </span><span class="cov0" title="0">{
                v1.GET("/ping", func(ctx echo.Context) error </span><span class="cov0" title="0">{
                        err := ctx.String(http.StatusOK, "pong")
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                })

                <span class="cov0" title="0">h.initUsersRoutes(v1)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package v1

import (
        "github.com/labstack/echo/v4"
        "github.com/maxzhovtyj/financeApp-server/pkg/logger"
)

type Error struct {
        Message string `json:"message"`
}

func newErrorResponse(ctx echo.Context, code int, err error) error <span class="cov10" title="11">{
        ctx.Response().Status = code

        _, responseErr := ctx.Response().Write([]byte(err.Error()))
        if responseErr != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Logging error
        <span class="cov10" title="11">logger.Error(err)

        return err</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package v1

import (
        "errors"
        "github.com/labstack/echo/v4"
        "github.com/maxzhovtyj/financeApp-server/internal/models"
        "net/http"
)

const signUpUrl = "/sign-up"

type signInUserInput struct {
        Email    string `json:"email" validate:"required"`
        Password string `json:"password" validate:"required"`
}

func (h *Handler) initUsersRoutes(group *echo.Group) <span class="cov0" title="0">{
        users := group.Group("/users")
        </span><span class="cov0" title="0">{
                users.POST(signUpUrl, h.signUp)
                users.POST("/sign-in", h.signIn)
        }</span>
}

func (h *Handler) signUp(ctx echo.Context) error <span class="cov10" title="7">{
        var input models.User

        if err := ctx.Bind(&amp;input); err != nil </span><span class="cov0" title="0">{
                return newErrorResponse(ctx, http.StatusBadRequest, models.ErrInvalidInputBody)
        }</span>

        <span class="cov10" title="7">err := ctx.Validate(&amp;input)
        if err != nil </span><span class="cov8" title="5">{
                return newErrorResponse(ctx, http.StatusBadRequest, models.ErrInvalidInputBody)
        }</span>

        <span class="cov4" title="2">if len(input.Password) &lt; 8 </span><span class="cov1" title="1">{
                return newErrorResponse(ctx, http.StatusBadRequest, models.ErrInvalidInputBody)
        }</span>

        <span class="cov1" title="1">err = h.service.Users.SignUp(ctx.Request().Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrUserAlreadyExists) </span><span class="cov0" title="0">{
                        return newErrorResponse(ctx, http.StatusBadRequest, models.ErrUserAlreadyExists)
                }</span>

                <span class="cov0" title="0">return newErrorResponse(ctx, http.StatusInternalServerError, err)</span>
        }

        <span class="cov1" title="1">return ctx.NoContent(http.StatusCreated)</span>
}

func (h *Handler) signIn(ctx echo.Context) error <span class="cov9" title="6">{
        var input signInUserInput

        if err := ctx.Bind(&amp;input); err != nil </span><span class="cov0" title="0">{
                return newErrorResponse(ctx, http.StatusBadRequest, models.ErrInvalidInputBody)
        }</span>

        <span class="cov9" title="6">if err := ctx.Validate(&amp;input); err != nil </span><span class="cov6" title="3">{
                return newErrorResponse(ctx, http.StatusBadRequest, models.ErrInvalidInputBody)
        }</span>

        <span class="cov6" title="3">accessToken, refreshToken, err := h.service.Users.SignIn(ctx.Request().Context(), input.Email, input.Password)
        if err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, models.ErrUserNotFound) </span><span class="cov1" title="1">{
                        return newErrorResponse(ctx, http.StatusBadRequest, models.ErrUserNotFound)
                }</span>

                <span class="cov1" title="1">return newErrorResponse(ctx, http.StatusInternalServerError, err)</span>
        }

        <span class="cov1" title="1">return ctx.JSON(http.StatusOK, map[string]any{
                "accessToken":  accessToken,
                "refreshToken": refreshToken,
        })</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package v1

import (
        "github.com/go-playground/validator/v10"
        "github.com/labstack/echo/v4"
        "net/http"
)

type AppValidator struct {
        Validator *validator.Validate
}

func (av *AppValidator) Validate(i interface{}) error <span class="cov10" title="13">{
        if err := av.Validator.Struct(i); err != nil </span><span class="cov8" title="8">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov6" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package repository

import (
        "context"
        "github.com/maxzhovtyj/financeApp-server/internal/models"
        "go.mongodb.org/mongo-driver/mongo"
)

type Users interface {
        Create(ctx context.Context, user models.User) error
        GetByCredentials(ctx context.Context, email, password string) (models.User, error)
}

type Repository struct {
        Users Users
}

func New(db *mongo.Database) *Repository <span class="cov0" title="0">{
        return &amp;Repository{Users: NewUsersRepo(db)}
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package repository

import (
        "context"
        "errors"
        "github.com/maxzhovtyj/financeApp-server/internal/models"
        "github.com/maxzhovtyj/financeApp-server/pkg/db/mongodb"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
)

type UsersRepo struct {
        db *mongo.Collection
}

func NewUsersRepo(db *mongo.Database) *UsersRepo <span class="cov0" title="0">{
        return &amp;UsersRepo{db: db.Collection(userCollection)}
}</span>

func (r *UsersRepo) Create(ctx context.Context, user models.User) error <span class="cov0" title="0">{
        _, err := r.db.InsertOne(ctx, user)
        if mongodb.IsDuplicate(err) </span><span class="cov0" title="0">{
                return models.ErrUserAlreadyExists
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (r *UsersRepo) GetByCredentials(ctx context.Context, email, password string) (models.User, error) <span class="cov0" title="0">{
        var user models.User

        err := r.db.FindOne(ctx, bson.M{"email": email, "password": password}).Decode(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, mongo.ErrNoDocuments) </span><span class="cov0" title="0">{
                        return user, models.ErrUserNotFound
                }</span>

                <span class="cov0" title="0">return models.User{}, err</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package server

import (
        "github.com/labstack/echo/v4"
        "github.com/maxzhovtyj/financeApp-server/internal/config"
)

type Server struct {
        echo    *echo.Echo
        address string
}

func NewServer(cfg *config.Config, e *echo.Echo) *Server <span class="cov0" title="0">{
        e.Server.MaxHeaderBytes = cfg.HTTP.MaxHeaderMegabytes &lt;&lt; 20
        e.Server.ReadTimeout = cfg.HTTP.ReadTimeout
        e.Server.WriteTimeout = cfg.HTTP.WriteTimeout

        return &amp;Server{
                echo:    e,
                address: ":" + cfg.HTTP.Port,
        }
}</span>

func (s *Server) Run() error <span class="cov0" title="0">{
        return s.echo.Start(s.address)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: service.go

// Package mock_service is a generated GoMock package.
package mock_service

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        models "github.com/maxzhovtyj/financeApp-server/internal/models"
)

// MockUsers is a mock of Users interface.
type MockUsers struct {
        ctrl     *gomock.Controller
        recorder *MockUsersMockRecorder
}

// MockUsersMockRecorder is the mock recorder for MockUsers.
type MockUsersMockRecorder struct {
        mock *MockUsers
}

// NewMockUsers creates a new mock instance.
func NewMockUsers(ctrl *gomock.Controller) *MockUsers <span class="cov10" title="13">{
        mock := &amp;MockUsers{ctrl: ctrl}
        mock.recorder = &amp;MockUsersMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUsers) EXPECT() *MockUsersMockRecorder <span class="cov5" title="4">{
        return m.recorder
}</span>

// SignIn mocks base method.
func (m *MockUsers) SignIn(ctx context.Context, email, password string) (string, string, error) <span class="cov4" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SignIn", ctx, email, password)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(string)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// SignIn indicates an expected call of SignIn.
func (mr *MockUsersMockRecorder) SignIn(ctx, email, password interface{}) *gomock.Call <span class="cov4" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignIn", reflect.TypeOf((*MockUsers)(nil).SignIn), ctx, email, password)
}</span>

// SignUp mocks base method.
func (m *MockUsers) SignUp(ctx context.Context, user models.User) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SignUp", ctx, user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SignUp indicates an expected call of SignUp.
func (mr *MockUsersMockRecorder) SignUp(ctx, user interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignUp", reflect.TypeOf((*MockUsers)(nil).SignUp), ctx, user)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package service

import (
        "context"
        "github.com/maxzhovtyj/financeApp-server/internal/models"
        "github.com/maxzhovtyj/financeApp-server/internal/repository"
        "github.com/maxzhovtyj/financeApp-server/pkg/auth"
        "github.com/maxzhovtyj/financeApp-server/pkg/hash"
        "time"
)

//go:generate mockgen -source=service.go -destination=mocks/mock.go

type Users interface {
        SignUp(ctx context.Context, user models.User) error
        SignIn(ctx context.Context, email, password string) (string, string, error)
}

type Service struct {
        Users Users
}

func New(
        repo *repository.Repository,
        tokenManager auth.TokenManager,
        accessTokenTTL, refreshTokenTTL time.Duration,
        hashing hash.PasswordHashing) *Service <span class="cov0" title="0">{
        return &amp;Service{
                Users: NewUsersService(repo.Users, tokenManager, accessTokenTTL, refreshTokenTTL, hashing),
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package service

import (
        "context"
        "errors"
        "github.com/maxzhovtyj/financeApp-server/internal/models"
        "github.com/maxzhovtyj/financeApp-server/internal/repository"
        "github.com/maxzhovtyj/financeApp-server/pkg/auth"
        "github.com/maxzhovtyj/financeApp-server/pkg/hash"
        "time"
)

type UserService struct {
        repo         repository.Users
        tokenManager auth.TokenManager

        accessTokenTTL  time.Duration
        refreshTokenTTL time.Duration

        hashing hash.PasswordHashing
}

func NewUsersService(
        repo repository.Users,
        tokenManager auth.TokenManager,
        accessTokenTTL, refreshTokenTTL time.Duration,
        hashing hash.PasswordHashing) Users <span class="cov0" title="0">{
        return &amp;UserService{
                repo:            repo,
                tokenManager:    tokenManager,
                accessTokenTTL:  accessTokenTTL,
                refreshTokenTTL: refreshTokenTTL,
                hashing:         hashing,
        }
}</span>

func (s *UserService) SignUp(ctx context.Context, user models.User) (err error) <span class="cov0" title="0">{
        user.Password, err = s.hashing.Hash(user.Password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.repo.Create(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrUserAlreadyExists) </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *UserService) SignIn(ctx context.Context, email, password string) (string, string, error) <span class="cov0" title="0">{
        passwordHash, err := s.hashing.Hash(password)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">user, err := s.repo.GetByCredentials(ctx, email, passwordHash)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, models.ErrUserNotFound) </span><span class="cov0" title="0">{
                        return "", "", err
                }</span>

                <span class="cov0" title="0">return "", "", err</span>
        }

        <span class="cov0" title="0">accessToken, err := s.tokenManager.NewJWT(user.Id.String(), s.accessTokenTTL)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">refreshToken, err := s.tokenManager.NewRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">return accessToken, refreshToken, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package auth

import (
        "errors"
        "fmt"
        "math/rand"
        "time"

        "github.com/dgrijalva/jwt-go"
)

// TokenManager provides logic for JWT &amp; Refresh tokens generation and parsing.
type TokenManager interface {
        NewJWT(userId string, ttl time.Duration) (string, error)
        Parse(accessToken string) (string, error)
        NewRefreshToken() (string, error)
}

type Manager struct {
        signingKey string
}

func NewManager(signingKey string) (*Manager, error) <span class="cov8" title="1">{
        if signingKey == "" </span><span class="cov0" title="0">{
                return nil, errors.New("empty signing key")
        }</span>

        <span class="cov8" title="1">return &amp;Manager{signingKey: signingKey}, nil</span>
}

func (m *Manager) NewJWT(userId string, ttl time.Duration) (string, error) <span class="cov8" title="1">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.StandardClaims{
                ExpiresAt: time.Now().Add(ttl).Unix(),
                Subject:   userId,
        })

        return token.SignedString([]byte(m.signingKey))
}</span>

func (m *Manager) Parse(accessToken string) (string, error) <span class="cov0" title="0">{
        token, err := jwt.Parse(accessToken, func(token *jwt.Token) (i interface{}, err error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>

                <span class="cov0" title="0">return []byte(m.signingKey), nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error get user claims from token")
        }</span>

        <span class="cov0" title="0">return claims["sub"].(string), nil</span>
}

func (m *Manager) NewRefreshToken() (string, error) <span class="cov8" title="1">{
        b := make([]byte, 32)

        s := rand.NewSource(time.Now().Unix())
        r := rand.New(s)

        if _, err := r.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%x", b), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package mongodb

import (
        "context"
        "errors"
        "fmt"
        "github.com/maxzhovtyj/financeApp-server/internal/config"
        "github.com/maxzhovtyj/financeApp-server/pkg/logger"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "time"
)

func New(cfg config.MongoConfig) *mongo.Client <span class="cov0" title="0">{
        ctx, cancelFunc := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancelFunc()

        dsn := fmt.Sprintf(cfg.URI)

        client, err := mongo.Connect(ctx, options.Client().ApplyURI(dsn).SetAuth(options.Credential{
                Username: cfg.User,
                Password: cfg.Password,
        }))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span>

        <span class="cov0" title="0">err = client.Ping(context.Background(), nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span>

        <span class="cov0" title="0">return client</span>
}

func IsDuplicate(err error) bool <span class="cov0" title="0">{
        var e mongo.WriteException
        if errors.As(err, &amp;e) </span><span class="cov0" title="0">{
                for _, we := range e.WriteErrors </span><span class="cov0" title="0">{
                        if we.Code == 11000 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package hash

import (
        "crypto/sha1"
        "fmt"
)

// PasswordHashing provides hashing logic to securely store passwords.
type PasswordHashing interface {
        Hash(password string) (string, error)
}

// SHA1Hashing uses SHA1 to hash passwords with provided salt.
type SHA1Hashing struct {
        salt string
}

func NewSHA1Hashing(salt string) *SHA1Hashing <span class="cov0" title="0">{
        return &amp;SHA1Hashing{salt: salt}
}</span>

// Hash creates SHA1 hash of given password.
func (h *SHA1Hashing) Hash(password string) (string, error) <span class="cov0" title="0">{
        hash := sha1.New()

        if _, err := hash.Write([]byte(password)); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%x", hash.Sum([]byte(h.salt))), nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package logger

import (
        "github.com/sirupsen/logrus"
)

// TODO create general interface with generic fields

func Debug(msg ...interface{}) <span class="cov0" title="0">{
        logrus.Debug(msg...)
}</span>

func Debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        logrus.Debugf(format, args...)
}</span>

func Info(msg ...interface{}) <span class="cov0" title="0">{
        logrus.Info(msg...)
}</span>

func Infof(format string, args ...interface{}) <span class="cov0" title="0">{
        logrus.Infof(format, args...)
}</span>

func Warn(msg ...interface{}) <span class="cov0" title="0">{
        logrus.Warn(msg...)
}</span>

func Warnf(format string, args ...interface{}) <span class="cov0" title="0">{
        logrus.Warnf(format, args...)
}</span>

func Error(msg ...interface{}) <span class="cov10" title="11">{
        logrus.Error(msg...)
}</span>

func Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        logrus.Errorf(format, args...)
}</span>

func Fatal(args ...interface{}) <span class="cov0" title="0">{
        logrus.Fatal(args...)
}</span>

func Panic(args ...interface{}) <span class="cov0" title="0">{
        logrus.Panic(args...)
}</span>

func Println(args ...interface{}) <span class="cov0" title="0">{
        logrus.Println(args...)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash !== "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
